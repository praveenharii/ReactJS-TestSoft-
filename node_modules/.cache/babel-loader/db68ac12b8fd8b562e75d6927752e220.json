{"ast":null,"code":"/*! Moment Duration Format v2.2.2\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-02-16\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['moment'], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but only CommonJS-like\n    // enviroments that support module.exports, like Node.\n    try {\n      module.exports = factory(require('moment'));\n    } catch (e) {\n      // If moment is not available, leave the setup up to the user.\n      // Like when using moment-timezone or similar moment-based package.\n      module.exports = factory;\n    }\n  }\n  if (root) {\n    // Globals.\n    root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n  }\n})(this, function (moment) {\n  // `Number#tolocaleString` is tested on plugin initialization.\n  // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n  // native function will be used to generate formatted output. If the feature\n  // test fails, the fallback format function internal to this plugin will be\n  // used.\n  var toLocaleStringWorks = false;\n\n  // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `toLocaleString` will be used for formatting,\n  // the plugin will \"pre-round\" number values using the fallback number format\n  // function before passing them to `toLocaleString` for final formatting.\n  var toLocaleStringRoundingWorks = false;\n\n  // `Intl.NumberFormat#format` is tested on plugin initialization.\n  // If the feature test passes, `intlNumberFormatRoundingWorks` will be set to\n  // `true` and the native function will be used to generate formatted output.\n  // If the feature test fails, either `Number#tolocaleString` (if\n  // `toLocaleStringWorks` is `true`), or the fallback format function internal\n  //  to this plugin will be used.\n  var intlNumberFormatWorks = false;\n\n  // `Intl.NumberFormat#format` rounds incorrectly for select numbers in Microsoft\n  // environments (Edge, IE11, Windows Phone) and possibly other environments.\n  // If the rounding test fails and `Intl.NumberFormat#format` will be used for\n  // formatting, the plugin will \"pre-round\" number values using the fallback number\n  // format function before passing them to `Intl.NumberFormat#format` for final\n  // formatting.\n  var intlNumberFormatRoundingWorks = false;\n\n  // Token type names in order of descending magnitude.\n  var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n  var bubbles = [{\n    type: \"seconds\",\n    targets: [{\n      type: \"minutes\",\n      value: 60\n    }, {\n      type: \"hours\",\n      value: 3600\n    }, {\n      type: \"days\",\n      value: 86400\n    }, {\n      type: \"weeks\",\n      value: 604800\n    }, {\n      type: \"months\",\n      value: 2678400\n    }, {\n      type: \"years\",\n      value: 31536000\n    }]\n  }, {\n    type: \"minutes\",\n    targets: [{\n      type: \"hours\",\n      value: 60\n    }, {\n      type: \"days\",\n      value: 1440\n    }, {\n      type: \"weeks\",\n      value: 10080\n    }, {\n      type: \"months\",\n      value: 44640\n    }, {\n      type: \"years\",\n      value: 525600\n    }]\n  }, {\n    type: \"hours\",\n    targets: [{\n      type: \"days\",\n      value: 24\n    }, {\n      type: \"weeks\",\n      value: 168\n    }, {\n      type: \"months\",\n      value: 744\n    }, {\n      type: \"years\",\n      value: 8760\n    }]\n  }, {\n    type: \"days\",\n    targets: [{\n      type: \"weeks\",\n      value: 7\n    }, {\n      type: \"months\",\n      value: 31\n    }, {\n      type: \"years\",\n      value: 365\n    }]\n  }, {\n    type: \"months\",\n    targets: [{\n      type: \"years\",\n      value: 12\n    }]\n  }];\n\n  // stringIncludes\n  function stringIncludes(str, search) {\n    if (search.length > str.length) {\n      return false;\n    }\n    return str.indexOf(search) !== -1;\n  }\n\n  // repeatZero(qty)\n  // Returns \"0\" repeated `qty` times.\n  // `qty` must be a integer >= 0.\n  function repeatZero(qty) {\n    var result = \"\";\n    while (qty) {\n      result += \"0\";\n      qty -= 1;\n    }\n    return result;\n  }\n  function stringRound(digits) {\n    var digitsArray = digits.split(\"\").reverse();\n    var i = 0;\n    var carry = true;\n    while (carry && i < digitsArray.length) {\n      if (i) {\n        if (digitsArray[i] === \"9\") {\n          digitsArray[i] = \"0\";\n        } else {\n          digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n          carry = false;\n        }\n      } else {\n        if (parseInt(digitsArray[i], 10) < 5) {\n          carry = false;\n        }\n        digitsArray[i] = \"0\";\n      }\n      i += 1;\n    }\n    if (carry) {\n      digitsArray.push(\"1\");\n    }\n    return digitsArray.reverse().join(\"\");\n  }\n\n  // cachedNumberFormat\n  // Returns an `Intl.NumberFormat` instance for the given locale and configuration.\n  // On first use of a particular configuration, the instance is cached for fast\n  // repeat access.\n  function cachedNumberFormat(locale, options) {\n    // Create a sorted, stringified version of `options`\n    // for use as part of the cache key\n    var optionsString = map(keys(options).sort(), function (key) {\n      return key + ':' + options[key];\n    }).join(',');\n\n    // Set our cache key\n    var cacheKey = locale + '+' + optionsString;\n\n    // If we don't have this configuration cached, configure and cache it\n    if (!cachedNumberFormat.cache[cacheKey]) {\n      cachedNumberFormat.cache[cacheKey] = Intl.NumberFormat(locale, options);\n    }\n\n    // Return the cached version of this configuration\n    return cachedNumberFormat.cache[cacheKey];\n  }\n  cachedNumberFormat.cache = {};\n\n  // formatNumber\n  // Formats any number greater than or equal to zero using these options:\n  // - userLocale\n  // - useToLocaleString\n  // - useGrouping\n  // - grouping\n  // - maximumSignificantDigits\n  // - minimumIntegerDigits\n  // - fractionDigits\n  // - groupingSeparator\n  // - decimalSeparator\n  //\n  // `useToLocaleString` will use `Intl.NumberFormat` or `toLocaleString` for formatting.\n  // `userLocale` option is passed through to the formatting function.\n  // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n  // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n  function formatNumber(number, options, userLocale) {\n    var useToLocaleString = options.useToLocaleString;\n    var useGrouping = options.useGrouping;\n    var grouping = useGrouping && options.grouping.slice();\n    var maximumSignificantDigits = options.maximumSignificantDigits;\n    var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n    var fractionDigits = options.fractionDigits || 0;\n    var groupingSeparator = options.groupingSeparator;\n    var decimalSeparator = options.decimalSeparator;\n    if (useToLocaleString && userLocale) {\n      var localeStringOptions = {\n        minimumIntegerDigits: minimumIntegerDigits,\n        useGrouping: useGrouping\n      };\n      if (fractionDigits) {\n        localeStringOptions.maximumFractionDigits = fractionDigits;\n        localeStringOptions.minimumFractionDigits = fractionDigits;\n      }\n\n      // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n      // when maximumSignificantDigits is set. See #96.\n      if (maximumSignificantDigits && number > 0) {\n        localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n      }\n      if (intlNumberFormatWorks) {\n        if (!intlNumberFormatRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n        return cachedNumberFormat(userLocale, localeStringOptions).format(number);\n      } else {\n        if (!toLocaleStringRoundingWorks) {\n          var roundingOptions = extend({}, options);\n          roundingOptions.useGrouping = false;\n          roundingOptions.decimalSeparator = \".\";\n          number = parseFloat(formatNumber(number, roundingOptions), 10);\n        }\n        return number.toLocaleString(userLocale, localeStringOptions);\n      }\n    }\n    var numberString;\n\n    // Add 1 to digit output length for floating point errors workaround. See below.\n    if (maximumSignificantDigits) {\n      numberString = number.toPrecision(maximumSignificantDigits + 1);\n    } else {\n      numberString = number.toFixed(fractionDigits + 1);\n    }\n    var integerString;\n    var fractionString;\n    var exponentString;\n    var temp = numberString.split(\"e\");\n    exponentString = temp[1] || \"\";\n    temp = temp[0].split(\".\");\n    fractionString = temp[1] || \"\";\n    integerString = temp[0] || \"\";\n\n    // Workaround for floating point errors in `toFixed` and `toPrecision`.\n    // (3.55).toFixed(1); --> \"3.5\"\n    // (123.55 - 120).toPrecision(2); --> \"3.5\"\n    // (123.55 - 120); --> 3.549999999999997\n    // (123.55 - 120).toFixed(2); --> \"3.55\"\n    // Round by examing the string output of the next digit.\n\n    // *************** Implement String Rounding here ***********************\n    // Check integerString + fractionString length of toPrecision before rounding.\n    // Check length of fractionString from toFixed output before rounding.\n    var integerLength = integerString.length;\n    var fractionLength = fractionString.length;\n    var digitCount = integerLength + fractionLength;\n    var digits = integerString + fractionString;\n    if (maximumSignificantDigits && digitCount === maximumSignificantDigits + 1 || !maximumSignificantDigits && fractionLength === fractionDigits + 1) {\n      // Round digits.\n      digits = stringRound(digits);\n      if (digits.length === digitCount + 1) {\n        integerLength = integerLength + 1;\n      }\n\n      // Discard final fractionDigit.\n      if (fractionLength) {\n        digits = digits.slice(0, -1);\n      }\n\n      // Separate integer and fraction.\n      integerString = digits.slice(0, integerLength);\n      fractionString = digits.slice(integerLength);\n    }\n\n    // Trim trailing zeroes from fractionString because toPrecision outputs\n    // precision, not significant digits.\n    if (maximumSignificantDigits) {\n      fractionString = fractionString.replace(/0*$/, \"\");\n    }\n\n    // Handle exponent.\n    var exponent = parseInt(exponentString, 10);\n    if (exponent > 0) {\n      if (fractionString.length <= exponent) {\n        fractionString = fractionString + repeatZero(exponent - fractionString.length);\n        integerString = integerString + fractionString;\n        fractionString = \"\";\n      } else {\n        integerString = integerString + fractionString.slice(0, exponent);\n        fractionString = fractionString.slice(exponent);\n      }\n    } else if (exponent < 0) {\n      fractionString = repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString;\n      integerString = \"0\";\n    }\n    if (!maximumSignificantDigits) {\n      // Trim or pad fraction when not using maximumSignificantDigits.\n      fractionString = fractionString.slice(0, fractionDigits);\n      if (fractionString.length < fractionDigits) {\n        fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n      }\n\n      // Pad integer when using minimumIntegerDigits\n      // and not using maximumSignificantDigits.\n      if (integerString.length < minimumIntegerDigits) {\n        integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n      }\n    }\n    var formattedString = \"\";\n\n    // Handle grouping.\n    if (useGrouping) {\n      temp = integerString;\n      var group;\n      while (temp.length) {\n        if (grouping.length) {\n          group = grouping.shift();\n        }\n        if (formattedString) {\n          formattedString = groupingSeparator + formattedString;\n        }\n        formattedString = temp.slice(-group) + formattedString;\n        temp = temp.slice(0, -group);\n      }\n    } else {\n      formattedString = integerString;\n    }\n\n    // Add decimalSeparator and fraction.\n    if (fractionString) {\n      formattedString = formattedString + decimalSeparator + fractionString;\n    }\n    return formattedString;\n  }\n\n  // durationLabelCompare\n  function durationLabelCompare(a, b) {\n    if (a.label.length > b.label.length) {\n      return -1;\n    }\n    if (a.label.length < b.label.length) {\n      return 1;\n    }\n\n    // a must be equal to b\n    return 0;\n  }\n\n  // durationGetLabels\n  function durationGetLabels(token, localeData) {\n    var labels = [];\n    each(keys(localeData), function (localeDataKey) {\n      if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n        return;\n      }\n      var labelType = localeDataKey.slice(15).toLowerCase();\n      each(keys(localeData[localeDataKey]), function (labelKey) {\n        if (labelKey.slice(0, 1) === token) {\n          labels.push({\n            type: labelType,\n            key: labelKey,\n            label: localeData[localeDataKey][labelKey]\n          });\n        }\n      });\n    });\n    return labels;\n  }\n\n  // durationPluralKey\n  function durationPluralKey(token, integerValue, decimalValue) {\n    // Singular for a value of `1`, but not for `1.0`.\n    if (integerValue === 1 && decimalValue === null) {\n      return token;\n    }\n    return token + token;\n  }\n  var engLocale = {\n    durationLabelsStandard: {\n      S: 'millisecond',\n      SS: 'milliseconds',\n      s: 'second',\n      ss: 'seconds',\n      m: 'minute',\n      mm: 'minutes',\n      h: 'hour',\n      hh: 'hours',\n      d: 'day',\n      dd: 'days',\n      w: 'week',\n      ww: 'weeks',\n      M: 'month',\n      MM: 'months',\n      y: 'year',\n      yy: 'years'\n    },\n    durationLabelsShort: {\n      S: 'msec',\n      SS: 'msecs',\n      s: 'sec',\n      ss: 'secs',\n      m: 'min',\n      mm: 'mins',\n      h: 'hr',\n      hh: 'hrs',\n      d: 'dy',\n      dd: 'dys',\n      w: 'wk',\n      ww: 'wks',\n      M: 'mo',\n      MM: 'mos',\n      y: 'yr',\n      yy: 'yrs'\n    },\n    durationTimeTemplates: {\n      HMS: 'h:mm:ss',\n      HM: 'h:mm',\n      MS: 'm:ss'\n    },\n    durationLabelTypes: [{\n      type: \"standard\",\n      string: \"__\"\n    }, {\n      type: \"short\",\n      string: \"_\"\n    }],\n    durationPluralKey: durationPluralKey\n  };\n\n  // isArray\n  function isArray(array) {\n    return Object.prototype.toString.call(array) === \"[object Array]\";\n  }\n\n  // isObject\n  function isObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  }\n\n  // findLast\n  function findLast(array, callback) {\n    var index = array.length;\n    while (index -= 1) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n    }\n  }\n\n  // find\n  function find(array, callback) {\n    var index = 0;\n    var max = array && array.length || 0;\n    var match;\n    if (typeof callback !== \"function\") {\n      match = callback;\n      callback = function callback(item) {\n        return item === match;\n      };\n    }\n    while (index < max) {\n      if (callback(array[index])) {\n        return array[index];\n      }\n      index += 1;\n    }\n  }\n\n  // each\n  function each(array, callback) {\n    var index = 0,\n      max = array.length;\n    if (!array || !max) {\n      return;\n    }\n    while (index < max) {\n      if (callback(array[index], index) === false) {\n        return;\n      }\n      index += 1;\n    }\n  }\n\n  // map\n  function map(array, callback) {\n    var index = 0,\n      max = array.length,\n      ret = [];\n    if (!array || !max) {\n      return ret;\n    }\n    while (index < max) {\n      ret[index] = callback(array[index], index);\n      index += 1;\n    }\n    return ret;\n  }\n\n  // pluck\n  function pluck(array, prop) {\n    return map(array, function (item) {\n      return item[prop];\n    });\n  }\n\n  // compact\n  function compact(array) {\n    var ret = [];\n    each(array, function (item) {\n      if (item) {\n        ret.push(item);\n      }\n    });\n    return ret;\n  }\n\n  // unique\n  function unique(array) {\n    var ret = [];\n    each(array, function (_a) {\n      if (!find(ret, _a)) {\n        ret.push(_a);\n      }\n    });\n    return ret;\n  }\n\n  // intersection\n  function intersection(a, b) {\n    var ret = [];\n    each(a, function (_a) {\n      each(b, function (_b) {\n        if (_a === _b) {\n          ret.push(_a);\n        }\n      });\n    });\n    return unique(ret);\n  }\n\n  // rest\n  function rest(array, callback) {\n    var ret = [];\n    each(array, function (item, index) {\n      if (!callback(item)) {\n        ret = array.slice(index);\n        return false;\n      }\n    });\n    return ret;\n  }\n\n  // initial\n  function initial(array, callback) {\n    var reversed = array.slice().reverse();\n    return rest(reversed, callback).reverse();\n  }\n\n  // extend\n  function extend(a, b) {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n    return a;\n  }\n\n  // keys\n  function keys(a) {\n    var ret = [];\n    for (var key in a) {\n      if (a.hasOwnProperty(key)) {\n        ret.push(key);\n      }\n    }\n    return ret;\n  }\n\n  // any\n  function any(array, callback) {\n    var index = 0,\n      max = array.length;\n    if (!array || !max) {\n      return false;\n    }\n    while (index < max) {\n      if (callback(array[index], index) === true) {\n        return true;\n      }\n      index += 1;\n    }\n    return false;\n  }\n\n  // flatten\n  function flatten(array) {\n    var ret = [];\n    each(array, function (child) {\n      ret = ret.concat(child);\n    });\n    return ret;\n  }\n  function toLocaleStringSupportsLocales() {\n    var number = 0;\n    try {\n      number.toLocaleString('i');\n    } catch (e) {\n      return e.name === 'RangeError';\n    }\n    return false;\n  }\n  function featureTestFormatterRounding(formatter) {\n    return formatter(3.55, \"en\", {\n      useGrouping: false,\n      minimumIntegerDigits: 1,\n      minimumFractionDigits: 1,\n      maximumFractionDigits: 1\n    }) === \"3.6\";\n  }\n  function featureTestFormatter(formatter) {\n    var passed = true;\n\n    // Test minimumIntegerDigits.\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 1\n    }) === \"1\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 2\n    }) === \"01\";\n    passed = passed && formatter(1, \"en\", {\n      minimumIntegerDigits: 3\n    }) === \"001\";\n    if (!passed) {\n      return false;\n    }\n\n    // Test maximumFractionDigits and minimumFractionDigits.\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 0,\n      minimumFractionDigits: 0\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 1,\n      minimumFractionDigits: 1\n    }) === \"100.0\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 2,\n      minimumFractionDigits: 2\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumFractionDigits: 3,\n      minimumFractionDigits: 3\n    }) === \"99.990\";\n    if (!passed) {\n      return false;\n    }\n\n    // Test maximumSignificantDigits.\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 1\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 2\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 3\n    }) === \"100\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 4\n    }) === \"99.99\";\n    passed = passed && formatter(99.99, \"en\", {\n      maximumSignificantDigits: 5\n    }) === \"99.99\";\n    if (!passed) {\n      return false;\n    }\n\n    // Test grouping.\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: true\n    }) === \"1,000\";\n    passed = passed && formatter(1000, \"en\", {\n      useGrouping: false\n    }) === \"1000\";\n    if (!passed) {\n      return false;\n    }\n    return true;\n  }\n\n  // durationsFormat(durations [, template] [, precision] [, settings])\n  function durationsFormat() {\n    var args = [].slice.call(arguments);\n    var settings = {};\n    var durations;\n\n    // Parse arguments.\n    each(args, function (arg, index) {\n      if (!index) {\n        if (!isArray(arg)) {\n          throw \"Expected array as the first argument to durationsFormat.\";\n        }\n        durations = arg;\n      }\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    if (!durations || !durations.length) {\n      return [];\n    }\n    settings.returnMomentTypes = true;\n    var formattedDurations = map(durations, function (dur) {\n      return dur.format(settings);\n    });\n\n    // Merge token types from all durations.\n    var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n    var largest = settings.largest;\n    if (largest) {\n      outputTypes = outputTypes.slice(0, largest);\n    }\n    settings.returnMomentTypes = false;\n    settings.outputTypes = outputTypes;\n    return map(durations, function (dur) {\n      return dur.format(settings);\n    });\n  }\n\n  // durationFormat([template] [, precision] [, settings])\n  function durationFormat() {\n    var args = [].slice.call(arguments);\n    var settings = extend({}, this.format.defaults);\n\n    // Keep a shadow copy of this moment for calculating remainders.\n    // Perform all calculations on positive duration value, handle negative\n    // sign at the very end.\n    var asMilliseconds = this.asMilliseconds();\n    var asMonths = this.asMonths();\n\n    // Treat invalid durations as having a value of 0 milliseconds.\n    if (typeof this.isValid === \"function\" && this.isValid() === false) {\n      asMilliseconds = 0;\n      asMonths = 0;\n    }\n    var isNegative = asMilliseconds < 0;\n\n    // Two shadow copies are needed because of the way moment.js handles\n    // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n    var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n    var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n    // Parse arguments.\n    each(args, function (arg) {\n      if (typeof arg === \"string\" || typeof arg === \"function\") {\n        settings.template = arg;\n        return;\n      }\n      if (typeof arg === \"number\") {\n        settings.precision = arg;\n        return;\n      }\n      if (isObject(arg)) {\n        extend(settings, arg);\n      }\n    });\n    var momentTokens = {\n      years: \"y\",\n      months: \"M\",\n      weeks: \"w\",\n      days: \"d\",\n      hours: \"h\",\n      minutes: \"m\",\n      seconds: \"s\",\n      milliseconds: \"S\"\n    };\n    var tokenDefs = {\n      escape: /\\[(.+?)\\]/,\n      years: /\\*?[Yy]+/,\n      months: /\\*?M+/,\n      weeks: /\\*?[Ww]+/,\n      days: /\\*?[Dd]+/,\n      hours: /\\*?[Hh]+/,\n      minutes: /\\*?m+/,\n      seconds: /\\*?s+/,\n      milliseconds: /\\*?S+/,\n      general: /.+?/\n    };\n\n    // Types array is available in the template function.\n    settings.types = types;\n    var typeMap = function typeMap(token) {\n      return find(types, function (type) {\n        return tokenDefs[type].test(token);\n      });\n    };\n    var tokenizer = new RegExp(map(types, function (type) {\n      return tokenDefs[type].source;\n    }).join(\"|\"), \"g\");\n\n    // Current duration object is available in the template function.\n    settings.duration = this;\n\n    // Eval template function and cache template string.\n    var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n    // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n    // outputTypes is an array of moment token types that determines\n    // the tokens returned in formatted output. This option overrides\n    // trim, largest, stopTrim, etc.\n    var outputTypes = settings.outputTypes;\n\n    // returnMomentTypes is a boolean that sets durationFormat to return\n    // the processed momentTypes instead of formatted output.\n    var returnMomentTypes = settings.returnMomentTypes;\n    var largest = settings.largest;\n\n    // Setup stopTrim array of token types.\n    var stopTrim = [];\n    if (!outputTypes) {\n      if (isArray(settings.stopTrim)) {\n        settings.stopTrim = settings.stopTrim.join(\"\");\n      }\n\n      // Parse stopTrim string to create token types array.\n      if (settings.stopTrim) {\n        each(settings.stopTrim.match(tokenizer), function (token) {\n          var type = typeMap(token);\n          if (type === \"escape\" || type === \"general\") {\n            return;\n          }\n          stopTrim.push(type);\n        });\n      }\n    }\n\n    // Cache moment's locale data.\n    var localeData = moment.localeData();\n    if (!localeData) {\n      localeData = {};\n    }\n\n    // Fall back to this plugin's `eng` extension.\n    each(keys(engLocale), function (key) {\n      if (typeof engLocale[key] === \"function\") {\n        if (!localeData[key]) {\n          localeData[key] = engLocale[key];\n        }\n        return;\n      }\n      if (!localeData[\"_\" + key]) {\n        localeData[\"_\" + key] = engLocale[key];\n      }\n    });\n\n    // Replace Duration Time Template strings.\n    // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n    each(keys(localeData._durationTimeTemplates), function (item) {\n      template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n    });\n\n    // Determine user's locale.\n    var userLocale = settings.userLocale || moment.locale();\n    var useLeftUnits = settings.useLeftUnits;\n    var usePlural = settings.usePlural;\n    var precision = settings.precision;\n    var forceLength = settings.forceLength;\n    var useGrouping = settings.useGrouping;\n    var trunc = settings.trunc;\n\n    // Use significant digits only when precision is greater than 0.\n    var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n    var significantDigits = useSignificantDigits ? settings.precision : 0;\n    var significantDigitsCache = significantDigits;\n    var minValue = settings.minValue;\n    var isMinValue = false;\n    var maxValue = settings.maxValue;\n    var isMaxValue = false;\n\n    // formatNumber fallback options.\n    var useToLocaleString = settings.useToLocaleString;\n    var groupingSeparator = settings.groupingSeparator;\n    var decimalSeparator = settings.decimalSeparator;\n    var grouping = settings.grouping;\n    useToLocaleString = useToLocaleString && (toLocaleStringWorks || intlNumberFormatWorks);\n\n    // Trim options.\n    var trim = settings.trim;\n    if (isArray(trim)) {\n      trim = trim.join(\" \");\n    }\n    if (trim === null && (largest || maxValue || useSignificantDigits)) {\n      trim = \"all\";\n    }\n    if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n      trim = \"large\";\n    }\n    if (trim === false) {\n      trim = \"\";\n    }\n    var trimIncludes = function trimIncludes(item) {\n      return item.test(trim);\n    };\n    var rLarge = /large/;\n    var rSmall = /small/;\n    var rBoth = /both/;\n    var rMid = /mid/;\n    var rAll = /^all|[^sm]all/;\n    var rFinal = /final/;\n    var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n    var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n    var trimMid = any([rMid, rAll], trimIncludes);\n    var trimFinal = any([rFinal, rAll], trimIncludes);\n\n    // Parse format string to create raw tokens array.\n    var rawTokens = map(template.match(tokenizer), function (token, index) {\n      var type = typeMap(token);\n      if (token.slice(0, 1) === \"*\") {\n        token = token.slice(1);\n        if (type !== \"escape\" && type !== \"general\") {\n          stopTrim.push(type);\n        }\n      }\n      return {\n        index: index,\n        length: token.length,\n        text: \"\",\n        // Replace escaped tokens with the non-escaped token text.\n        token: type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token,\n        // Ignore type on non-moment tokens.\n        type: type === \"escape\" || type === \"general\" ? null : type\n      };\n    });\n\n    // Associate text tokens with moment tokens.\n    var currentToken = {\n      index: 0,\n      length: 0,\n      token: \"\",\n      text: \"\",\n      type: null\n    };\n    var tokens = [];\n    if (useLeftUnits) {\n      rawTokens.reverse();\n    }\n    each(rawTokens, function (token) {\n      if (token.type) {\n        if (currentToken.type || currentToken.text) {\n          tokens.push(currentToken);\n        }\n        currentToken = token;\n        return;\n      }\n      if (useLeftUnits) {\n        currentToken.text = token.token + currentToken.text;\n      } else {\n        currentToken.text += token.token;\n      }\n    });\n    if (currentToken.type || currentToken.text) {\n      tokens.push(currentToken);\n    }\n    if (useLeftUnits) {\n      tokens.reverse();\n    }\n\n    // Find unique moment token types in the template in order of\n    // descending magnitude.\n    var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n    // Exit early if there are no moment token types.\n    if (!momentTypes.length) {\n      return pluck(tokens, \"text\").join(\"\");\n    }\n\n    // Calculate values for each moment type in the template.\n    // For processing the settings, values are associated with moment types.\n    // Values will be assigned to tokens at the last step in order to\n    // assume nothing about frequency or order of tokens in the template.\n    momentTypes = map(momentTypes, function (momentType, index) {\n      // Is this the least-magnitude moment token found?\n      var isSmallest = index + 1 === momentTypes.length;\n\n      // Is this the greatest-magnitude moment token found?\n      var isLargest = !index;\n\n      // Get the raw value in the current units.\n      var rawValue;\n      if (momentType === \"years\" || momentType === \"months\") {\n        rawValue = remainderMonths.as(momentType);\n      } else {\n        rawValue = remainder.as(momentType);\n      }\n      var wholeValue = Math.floor(rawValue);\n      var decimalValue = rawValue - wholeValue;\n      var token = find(tokens, function (token) {\n        return momentType === token.type;\n      });\n      if (isLargest && maxValue && rawValue > maxValue) {\n        isMaxValue = true;\n      }\n      if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n        isMinValue = true;\n      }\n\n      // Note the length of the largest-magnitude moment token:\n      // if it is greater than one and forceLength is not set,\n      // then default forceLength to `true`.\n      //\n      // Rationale is this: If the template is \"h:mm:ss\" and the\n      // moment value is 5 minutes, the user-friendly output is\n      // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n      // even though it has length of two if the template is \"h:mm:ss\";\n      //\n      // If the minutes output should always include the leading zero\n      // even when the hour is trimmed then set `{ forceLength: true }`\n      // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n      // clearly wanted everything padded so we should output \"05:00\";\n      //\n      // If the user wants the full padded output, they can use\n      // template \"hh:mm:ss\" and set `{ trim: false }` to output\n      // \"00:05:00\".\n      if (isLargest && forceLength === null && token.length > 1) {\n        forceLength = true;\n      }\n\n      // Update remainder.\n      remainder.subtract(wholeValue, momentType);\n      remainderMonths.subtract(wholeValue, momentType);\n      return {\n        rawValue: rawValue,\n        wholeValue: wholeValue,\n        // Decimal value is only retained for the least-magnitude\n        // moment type in the format template.\n        decimalValue: isSmallest ? decimalValue : 0,\n        isSmallest: isSmallest,\n        isLargest: isLargest,\n        type: momentType,\n        // Tokens can appear multiple times in a template string,\n        // but all instances must share the same length.\n        tokenLength: token.length\n      };\n    });\n    var truncMethod = trunc ? Math.floor : Math.round;\n    var truncate = function truncate(value, places) {\n      var factor = Math.pow(10, places);\n      return truncMethod(value * factor) / factor;\n    };\n    var foundFirst = false;\n    var bubbled = false;\n    var formatValue = function formatValue(momentType, index) {\n      var formatOptions = {\n        useGrouping: useGrouping,\n        groupingSeparator: groupingSeparator,\n        decimalSeparator: decimalSeparator,\n        grouping: grouping,\n        useToLocaleString: useToLocaleString\n      };\n      if (useSignificantDigits) {\n        if (significantDigits <= 0) {\n          momentType.rawValue = 0;\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        } else {\n          formatOptions.maximumSignificantDigits = significantDigits;\n          momentType.significantDigits = significantDigits;\n        }\n      }\n      if (isMaxValue && !bubbled) {\n        if (momentType.isLargest) {\n          momentType.wholeValue = maxValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n      if (isMinValue && !bubbled) {\n        if (momentType.isSmallest) {\n          momentType.wholeValue = minValue;\n          momentType.decimalValue = 0;\n        } else {\n          momentType.wholeValue = 0;\n          momentType.decimalValue = 0;\n        }\n      }\n      if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n        // Apply precision to least significant token value.\n        if (precision < 0) {\n          momentType.value = truncate(momentType.wholeValue, precision);\n        } else if (precision === 0) {\n          momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n        } else {\n          // precision > 0\n          if (useSignificantDigits) {\n            if (trunc) {\n              momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n            } else {\n              momentType.value = momentType.rawValue;\n            }\n            if (momentType.wholeValue) {\n              significantDigits -= momentType.wholeValue.toString().length;\n            }\n          } else {\n            formatOptions.fractionDigits = precision;\n            if (trunc) {\n              momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n            } else {\n              momentType.value = momentType.wholeValue + momentType.decimalValue;\n            }\n          }\n        }\n      } else {\n        if (useSignificantDigits && momentType.wholeValue) {\n          // Outer Math.round required here to handle floating point errors.\n          momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n          significantDigits -= momentType.wholeValue.toString().length;\n        } else {\n          momentType.value = momentType.wholeValue;\n        }\n      }\n      if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n        formatOptions.minimumIntegerDigits = momentType.tokenLength;\n        if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n          delete formatOptions.maximumSignificantDigits;\n        }\n      }\n      if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        foundFirst = true;\n      }\n      momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n      formatOptions.useGrouping = false;\n      formatOptions.decimalSeparator = \".\";\n      momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n      if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n        momentType.formattedValueMS = formatNumber(momentType.value, {\n          minimumIntegerDigits: 3,\n          useGrouping: false\n        }, \"en\").slice(0, 2);\n      }\n      return momentType;\n    };\n\n    // Calculate formatted values.\n    momentTypes = map(momentTypes, formatValue);\n    momentTypes = compact(momentTypes);\n\n    // Bubble rounded values.\n    if (momentTypes.length > 1) {\n      var findType = function findType(type) {\n        return find(momentTypes, function (momentType) {\n          return momentType.type === type;\n        });\n      };\n      var bubbleTypes = function bubbleTypes(bubble) {\n        var bubbleMomentType = findType(bubble.type);\n        if (!bubbleMomentType) {\n          return;\n        }\n        each(bubble.targets, function (target) {\n          var targetMomentType = findType(target.type);\n          if (!targetMomentType) {\n            return;\n          }\n          if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n            bubbleMomentType.rawValue = 0;\n            bubbleMomentType.wholeValue = 0;\n            bubbleMomentType.decimalValue = 0;\n            targetMomentType.rawValue += 1;\n            targetMomentType.wholeValue += 1;\n            targetMomentType.decimalValue = 0;\n            targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n            bubbled = true;\n          }\n        });\n      };\n      each(bubbles, bubbleTypes);\n    }\n\n    // Recalculate formatted values.\n    if (bubbled) {\n      foundFirst = false;\n      significantDigits = significantDigitsCache;\n      momentTypes = map(momentTypes, formatValue);\n      momentTypes = compact(momentTypes);\n    }\n    if (outputTypes && !(isMaxValue && !settings.trim)) {\n      momentTypes = map(momentTypes, function (momentType) {\n        if (find(outputTypes, function (outputType) {\n          return momentType.type === outputType;\n        })) {\n          return momentType;\n        }\n        return null;\n      });\n      momentTypes = compact(momentTypes);\n    } else {\n      // Trim Large.\n      if (trimLarge) {\n        momentTypes = rest(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - the smallest moment type\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n        });\n      }\n\n      // Largest.\n      if (largest && momentTypes.length) {\n        momentTypes = momentTypes.slice(0, largest);\n      }\n\n      // Trim Small.\n      if (trimSmall && momentTypes.length > 1) {\n        momentTypes = initial(momentTypes, function (momentType) {\n          // Stop trimming on:\n          // - a type marked for stopTrim\n          // - a type that has a whole value\n          // - the largest momentType\n          return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n        });\n      }\n\n      // Trim Mid.\n      if (trimMid) {\n        momentTypes = map(momentTypes, function (momentType, index) {\n          if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n            return null;\n          }\n          return momentType;\n        });\n        momentTypes = compact(momentTypes);\n      }\n\n      // Trim Final.\n      if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n        momentTypes = [];\n      }\n    }\n    if (returnMomentTypes) {\n      return momentTypes;\n    }\n\n    // Localize and pluralize unit labels.\n    each(tokens, function (token) {\n      var key = momentTokens[token.type];\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n      if (!key || !momentType) {\n        return;\n      }\n      var values = momentType.formattedValueEn.split(\".\");\n      values[0] = parseInt(values[0], 10);\n      if (values[1]) {\n        values[1] = parseFloat(\"0.\" + values[1], 10);\n      } else {\n        values[1] = null;\n      }\n      var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n      var labels = durationGetLabels(key, localeData);\n      var autoLocalized = false;\n      var pluralizedLabels = {};\n\n      // Auto-Localized unit labels.\n      each(localeData._durationLabelTypes, function (labelType) {\n        var label = find(labels, function (label) {\n          return label.type === labelType.type && label.key === pluralKey;\n        });\n        if (label) {\n          pluralizedLabels[label.type] = label.label;\n          if (stringIncludes(token.text, labelType.string)) {\n            token.text = token.text.replace(labelType.string, label.label);\n            autoLocalized = true;\n          }\n        }\n      });\n\n      // Auto-pluralized unit labels.\n      if (usePlural && !autoLocalized) {\n        labels.sort(durationLabelCompare);\n        each(labels, function (label) {\n          if (pluralizedLabels[label.type] === label.label) {\n            if (stringIncludes(token.text, label.label)) {\n              // Stop checking this token if its label is already\n              // correctly pluralized.\n              return false;\n            }\n\n            // Skip this label if it is correct, but not present in\n            // the token's text.\n            return;\n          }\n          if (stringIncludes(token.text, label.label)) {\n            // Replece this token's label and stop checking.\n            token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n            return false;\n          }\n        });\n      }\n    });\n\n    // Build ouptut.\n    tokens = map(tokens, function (token) {\n      if (!token.type) {\n        return token.text;\n      }\n      var momentType = find(momentTypes, function (momentType) {\n        return momentType.type === token.type;\n      });\n      if (!momentType) {\n        return \"\";\n      }\n      var out = \"\";\n      if (useLeftUnits) {\n        out += token.text;\n      }\n      if (isNegative && isMaxValue || !isNegative && isMinValue) {\n        out += \"< \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n      if (isNegative && isMinValue || !isNegative && isMaxValue) {\n        out += \"> \";\n        isMaxValue = false;\n        isMinValue = false;\n      }\n      if (isNegative && (momentType.value > 0 || trim === \"\" || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n        out += \"-\";\n        isNegative = false;\n      }\n      if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n        out += momentType.formattedValueMS;\n      } else {\n        out += momentType.formattedValue;\n      }\n      if (!useLeftUnits) {\n        out += token.text;\n      }\n      return out;\n    });\n\n    // Trim leading and trailing comma, space, colon, and dot.\n    return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n  }\n\n  // defaultFormatTemplate\n  function defaultFormatTemplate() {\n    var dur = this.duration;\n    var findType = function findType(type) {\n      return dur._data[type];\n    };\n    var firstType = find(this.types, findType);\n    var lastType = findLast(this.types, findType);\n\n    // Default template strings for each duration dimension type.\n    switch (firstType) {\n      case \"milliseconds\":\n        return \"S __\";\n      case \"seconds\": // Fallthrough.\n      case \"minutes\":\n        return \"*_MS_\";\n      case \"hours\":\n        return \"_HMS_\";\n      case \"days\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"d __\";\n        }\n      case \"weeks\":\n        if (firstType === lastType) {\n          return \"w __\";\n        }\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n        return \"w __, d __, h __\";\n      case \"months\":\n        // Possible Fallthrough.\n        if (firstType === lastType) {\n          return \"M __\";\n        }\n      case \"years\":\n        if (firstType === lastType) {\n          return \"y __\";\n        }\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n        return \"y __, M __, d __\";\n      default:\n        if (this.trim === null) {\n          this.trim = \"both\";\n        }\n        return \"y __, d __, h __, m __, s __\";\n    }\n  }\n\n  // init\n  function init(context) {\n    if (!context) {\n      throw \"Moment Duration Format init cannot find moment instance.\";\n    }\n    context.duration.format = durationsFormat;\n    context.duration.fn.format = durationFormat;\n    context.duration.fn.format.defaults = {\n      // Many options are defaulted to `null` to distinguish between\n      // 'not set' and 'set to `false`'\n\n      // trim\n      // Can be a string, a delimited list of strings, an array of strings,\n      // or a boolean.\n      // \"large\" - will trim largest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"small\" - will trim smallest-magnitude zero-value tokens until\n      // finding a token with a value, a token identified as 'stopTrim', or\n      // the final token of the format string.\n      // \"both\" - will execute \"large\" trim then \"small\" trim.\n      // \"mid\" - will trim any zero-value tokens that are not the first or\n      // last tokens. Usually used in conjunction with \"large\" or \"both\".\n      // e.g. \"large mid\" or \"both mid\".\n      // \"final\" - will trim the final token if it is zero-value. Use this\n      // option with \"large\" or \"both\" to output an empty string when\n      // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n      // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n      // \"left\" - maps to \"large\" to support plugin's version 1 API.\n      // \"right\" - maps to \"large\" to support plugin's version 1 API.\n      // `false` - template tokens are not trimmed.\n      // `true` - treated as \"large\".\n      // `null` - treated as \"large\".\n      trim: null,\n      // stopTrim\n      // A moment token string, a delimited set of moment token strings,\n      // or an array of moment token strings. Trimming will stop when a token\n      // listed in this option is reached. A \"*\" character in the format\n      // template string will also mark a moment token as stopTrim.\n      // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n      stopTrim: null,\n      // largest\n      // Set to a positive integer to output only the \"n\" largest-magnitude\n      // moment tokens that have a value. All lesser-magnitude moment tokens\n      // will be ignored. This option takes effect even if `trim` is set\n      // to `false`.\n      largest: null,\n      // maxValue\n      // Use `maxValue` to render generalized output for large duration values,\n      // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n      /// applied to the greatest-magnitude moment token in the format template.\n      maxValue: null,\n      // minValue\n      // Use `minValue` to render generalized output for small duration values,\n      // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n      // applied to the least-magnitude moment token in the format template.\n      minValue: null,\n      // precision\n      // If a positive integer, number of decimal fraction digits to render.\n      // If a negative integer, number of integer place digits to truncate to 0.\n      // If `useSignificantDigits` is set to `true` and `precision` is a positive\n      // integer, sets the maximum number of significant digits used in the\n      // formatted output.\n      precision: 0,\n      // trunc\n      // Default behavior rounds final token value. Set to `true` to\n      // truncate final token value, which was the default behavior in\n      // version 1 of this plugin.\n      trunc: false,\n      // forceLength\n      // Force first moment token with a value to render at full length\n      // even when template is trimmed and first moment token has length of 1.\n      forceLength: null,\n      // userLocale\n      // Formatted numerical output is rendered using `toLocaleString`\n      // and the locale of the user's environment. Set this option to render\n      // numerical output using a different locale. Unit names are rendered\n      // and detected using the locale set in moment.js, which can be different\n      // from the locale of user's environment.\n      userLocale: null,\n      // usePlural\n      // Will automatically singularize or pluralize unit names when they\n      // appear in the text associated with each moment token. Standard and\n      // short unit labels are singularized and pluralized, based on locale.\n      // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n      // of \"1 seconds\" or \"1 secs\". The default pluralization function\n      // renders a plural label for a value with decimal precision.\n      // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n      // Label types and pluralization function are configurable in the\n      // localeData extensions.\n      usePlural: true,\n      // useLeftUnits\n      // The text to the right of each moment token in a format string\n      // is treated as that token's units for the purposes of trimming,\n      // singularizing, and auto-localizing.\n      // e.g. \"h [hours], m [minutes], s [seconds]\".\n      // To properly singularize or localize a format string such as\n      // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n      // to the left of each moment token, set useLeftUnits to `true`.\n      // This plugin is not tested in the context of rtl text.\n      useLeftUnits: false,\n      // useGrouping\n      // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useGrouping: true,\n      // useSignificantDigits\n      // Treat the `precision` option as the maximum significant digits\n      // to be rendered. Precision must be a positive integer. Significant\n      // digits extend across unit types,\n      // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n      // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n      useSignificantDigits: false,\n      // template\n      // The template string used to format the duration. May be a function\n      // or a string. Template functions are executed with the `this` binding\n      // of the settings object so that template strings may be dynamically\n      // generated based on the duration object (accessible via `this.duration`)\n      // or any of the other settings. Leading and trailing space, comma,\n      // period, and colon characters are trimmed from the resulting string.\n      template: defaultFormatTemplate,\n      // useToLocaleString\n      // Set this option to `false` to ignore the `toLocaleString` feature\n      // test and force the use of the `formatNumber` fallback function\n      // included in this plugin.\n      useToLocaleString: true,\n      // formatNumber fallback options.\n      // When `toLocaleString` is detected and passes the feature test, the\n      // following options will have no effect: `toLocaleString` will be used\n      // for formatting and the grouping separator, decimal separator, and\n      // integer digit grouping will be determined by the user locale.\n\n      // groupingSeparator\n      // The integer digit grouping separator used when using the fallback\n      // formatNumber function.\n      groupingSeparator: \",\",\n      // decimalSeparator\n      // The decimal separator used when using the fallback formatNumber\n      // function.\n      decimalSeparator: \".\",\n      // grouping\n      // The integer digit grouping used when using the fallback formatNumber\n      // function. Must be an array. The default value of `[3]` gives the\n      // standard 3-digit thousand/million/billion digit groupings for the\n      // \"en\" locale. Setting this option to `[3, 2]` would generate the\n      // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n      grouping: [3]\n    };\n    context.updateLocale('en', engLocale);\n  }\n\n  // Run feature tests for `Number#toLocaleString`.\n  var toLocaleStringFormatter = function toLocaleStringFormatter(number, locale, options) {\n    return number.toLocaleString(locale, options);\n  };\n  toLocaleStringWorks = toLocaleStringSupportsLocales() && featureTestFormatter(toLocaleStringFormatter);\n  toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestFormatterRounding(toLocaleStringFormatter);\n\n  // Run feature tests for `Intl.NumberFormat#format`.\n  var intlNumberFormatFormatter = function intlNumberFormatFormatter(number, locale, options) {\n    if (typeof window !== 'undefined' && window && window.Intl && window.Intl.NumberFormat) {\n      return window.Intl.NumberFormat(locale, options).format(number);\n    }\n  };\n  intlNumberFormatWorks = featureTestFormatter(intlNumberFormatFormatter);\n  intlNumberFormatRoundingWorks = intlNumberFormatWorks && featureTestFormatterRounding(intlNumberFormatFormatter);\n\n  // Initialize duration format on the global moment instance.\n  init(moment);\n\n  // Return the init function so that duration format can be\n  // initialized on other moment instances.\n  return init;\n});","map":null,"metadata":{},"sourceType":"script"}