{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keypressBehavior = void 0;\nvar _dom = require(\"@testing-library/dom\");\nvar _shared = require(\"../shared\");\nvar _utils = require(\"../../utils\");\n\n/**\n * This file should cover the behavior for keys that produce character input\n */\nvar keypressBehavior = [{\n  matches: function matches(keyDef, element) {\n    var _keyDef$key;\n    return ((_keyDef$key = keyDef.key) == null ? void 0 : _keyDef$key.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'time',\n      readOnly: false\n    });\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _state$carryValue;\n    var newEntry = keyDef.key;\n    var textToBeTyped = ((_state$carryValue = state.carryValue) != null ? _state$carryValue : '') + newEntry;\n    var timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);\n    if ((0, _utils.isValidInputTimeValue)(element, timeNewEntry)) {\n      newEntry = timeNewEntry;\n    }\n    var _ref2 = (0, _utils.calculateNewValue)(newEntry, element),\n      newValue = _ref2.newValue,\n      newSelectionStart = _ref2.newSelectionStart;\n    var prevValue = (0, _utils.getValue)(element); // this check was provided by fireInputEventIfNeeded\n    // TODO: verify if it is even needed by this handler\n\n    if (prevValue !== newValue) {\n      (0, _shared.fireInputEvent)(element, {\n        newValue: newValue,\n        newSelectionStart: newSelectionStart,\n        eventOverrides: {\n          data: keyDef.key,\n          inputType: 'insertText'\n        }\n      });\n    }\n    (0, _shared.fireChangeForInputTimeIfValid)(element, prevValue, timeNewEntry);\n    state.carryValue = textToBeTyped;\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    var _keyDef$key2;\n    return ((_keyDef$key2 = keyDef.key) == null ? void 0 : _keyDef$key2.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'date',\n      readOnly: false\n    });\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _state$carryValue2;\n    var newEntry = keyDef.key;\n    var textToBeTyped = ((_state$carryValue2 = state.carryValue) != null ? _state$carryValue2 : '') + newEntry;\n    var isValidToBeTyped = (0, _utils.isValidDateValue)(element, textToBeTyped);\n    if (isValidToBeTyped) {\n      newEntry = textToBeTyped;\n    }\n    var _ref3 = (0, _utils.calculateNewValue)(newEntry, element),\n      newValue = _ref3.newValue,\n      newSelectionStart = _ref3.newSelectionStart;\n    var prevValue = (0, _utils.getValue)(element); // this check was provided by fireInputEventIfNeeded\n    // TODO: verify if it is even needed by this handler\n\n    if (prevValue !== newValue) {\n      (0, _shared.fireInputEvent)(element, {\n        newValue: newValue,\n        newSelectionStart: newSelectionStart,\n        eventOverrides: {\n          data: keyDef.key,\n          inputType: 'insertText'\n        }\n      });\n    }\n    if (isValidToBeTyped) {\n      _dom.fireEvent.change(element, {\n        target: {\n          value: textToBeTyped\n        }\n      });\n    }\n    state.carryValue = textToBeTyped;\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    var _keyDef$key3;\n    return ((_keyDef$key3 = keyDef.key) == null ? void 0 : _keyDef$key3.length) === 1 && (0, _utils.isElementType)(element, 'input', {\n      type: 'number',\n      readOnly: false\n    });\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _ref, _state$carryValue3, _newValue$match, _newValue$match2;\n    if (!/[\\d.\\-e]/.test(keyDef.key)) {\n      return;\n    }\n    var oldValue = (_ref = (_state$carryValue3 = state.carryValue) != null ? _state$carryValue3 : (0, _utils.getValue)(element)) != null ? _ref : /* istanbul ignore next */\n    '';\n    var _ref4 = (0, _utils.calculateNewValue)(keyDef.key, element, oldValue),\n      newValue = _ref4.newValue,\n      newSelectionStart = _ref4.newSelectionStart; // the browser allows some invalid input but not others\n    // it allows up to two '-' at any place before any 'e' or one directly following 'e'\n    // it allows one '.' at any place before e\n    var valueParts = newValue.split('e', 2);\n    if (Number((_newValue$match = newValue.match(/-/g)) == null ? void 0 : _newValue$match.length) > 2 || Number((_newValue$match2 = newValue.match(/\\./g)) == null ? void 0 : _newValue$match2.length) > 1 || valueParts[1] && !/^-?\\d*$/.test(valueParts[1])) {\n      return;\n    }\n    (0, _shared.fireInputEvent)(element, {\n      newValue: newValue,\n      newSelectionStart: newSelectionStart,\n      eventOverrides: {\n        data: keyDef.key,\n        inputType: 'insertText'\n      }\n    });\n    var appliedValue = (0, _utils.getValue)(element);\n    if (appliedValue === newValue) {\n      state.carryValue = undefined;\n    } else {\n      state.carryValue = newValue;\n    }\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    var _keyDef$key4;\n    return ((_keyDef$key4 = keyDef.key) == null ? void 0 : _keyDef$key4.length) === 1 && ((0, _utils.isElementType)(element, ['input', 'textarea'], {\n      readOnly: false\n    }) && !(0, _utils.isClickableInput)(element) || (0, _utils.isContentEditable)(element)) && (0, _utils.getSpaceUntilMaxLength)(element) !== 0;\n  },\n  handle: function handle(keyDef, element) {\n    var _ref5 = (0, _utils.calculateNewValue)(keyDef.key, element),\n      newValue = _ref5.newValue,\n      newSelectionStart = _ref5.newSelectionStart;\n    (0, _shared.fireInputEvent)(element, {\n      newValue: newValue,\n      newSelectionStart: newSelectionStart,\n      eventOverrides: {\n        data: keyDef.key,\n        inputType: 'insertText'\n      }\n    });\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    return keyDef.key === 'Enter' && ((0, _utils.isElementType)(element, 'textarea', {\n      readOnly: false\n    }) || (0, _utils.isContentEditable)(element)) && (0, _utils.getSpaceUntilMaxLength)(element) !== 0;\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _ref6 = (0, _utils.calculateNewValue)('\\n', element),\n      newValue = _ref6.newValue,\n      newSelectionStart = _ref6.newSelectionStart;\n    var inputType = (0, _utils.isContentEditable)(element) && !state.modifiers.shift ? 'insertParagraph' : 'insertLineBreak';\n    (0, _shared.fireInputEvent)(element, {\n      newValue: newValue,\n      newSelectionStart: newSelectionStart,\n      eventOverrides: {\n        inputType: inputType\n      }\n    });\n  }\n}];\nexports.keypressBehavior = keypressBehavior;","map":null,"metadata":{},"sourceType":"script"}