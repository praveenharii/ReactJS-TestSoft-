{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"D:\\\\React\\\\testapp1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _defineProperty = require(\"D:\\\\React\\\\testapp1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextKeyDef = getNextKeyDef;\nvar bracketDict;\n(function (bracketDict) {\n  bracketDict[\"{\"] = \"}\";\n  bracketDict[\"[\"] = \"]\";\n})(bracketDict || (bracketDict = {}));\nvar legacyModifiers;\n(function (legacyModifiers) {\n  legacyModifiers[\"alt\"] = \"alt\";\n  legacyModifiers[\"ctrl\"] = \"ctrl\";\n  legacyModifiers[\"meta\"] = \"meta\";\n  legacyModifiers[\"shift\"] = \"shift\";\n})(legacyModifiers || (legacyModifiers = {}));\nvar legacyKeyMap;\n/**\n * Get the next key from keyMap\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n * Modifiers like `{shift}` imply being kept pressed. This can be turned of per `{shift/}`.\n */\n\n(function (legacyKeyMap) {\n  legacyKeyMap[\"ctrl\"] = \"Control\";\n  legacyKeyMap[\"del\"] = \"Delete\";\n  legacyKeyMap[\"esc\"] = \"Escape\";\n  legacyKeyMap[\"space\"] = \" \";\n})(legacyKeyMap || (legacyKeyMap = {}));\nfunction getNextKeyDef(text, options) {\n  var _options$keyboardMap$;\n  var _readNextDescriptor = readNextDescriptor(text),\n    type = _readNextDescriptor.type,\n    descriptor = _readNextDescriptor.descriptor,\n    consumedLength = _readNextDescriptor.consumedLength,\n    releasePrevious = _readNextDescriptor.releasePrevious,\n    releaseSelf = _readNextDescriptor.releaseSelf,\n    repeat = _readNextDescriptor.repeat;\n  var keyDef = (_options$keyboardMap$ = options.keyboardMap.find(function (def) {\n    if (type === '[') {\n      var _def$code;\n      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();\n    } else if (type === '{') {\n      var _def$key;\n      var key = mapLegacyKey(descriptor);\n      return ((_def$key = def.key) == null ? void 0 : _def$key.toLowerCase()) === key.toLowerCase();\n    }\n    return def.key === descriptor;\n  })) != null ? _options$keyboardMap$ : _defineProperty({\n    key: 'Unknown',\n    code: 'Unknown'\n  }, type === '[' ? 'code' : 'key', descriptor);\n  return {\n    keyDef: keyDef,\n    consumedLength: consumedLength,\n    releasePrevious: releasePrevious,\n    releaseSelf: releaseSelf,\n    repeat: repeat\n  };\n}\nfunction readNextDescriptor(text) {\n  var pos = 0;\n  var startBracket = text[pos] in bracketDict ? text[pos] : '';\n  pos += startBracket.length; // `foo{{bar` is an escaped char at position 3,\n  // but `foo{{{>5}bar` should be treated as `{` pressed down for 5 keydowns.\n\n  var startBracketRepeated = startBracket ? text.match(new RegExp(\"^\\\\\".concat(startBracket, \"+\")))[0].length : 0;\n  var isEscapedChar = startBracketRepeated === 2 || startBracket === '{' && startBracketRepeated > 3;\n  var type = isEscapedChar ? '' : startBracket;\n  return _objectSpread({\n    type: type\n  }, type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type));\n}\nfunction readPrintableChar(text, pos) {\n  var descriptor = text[pos];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  return {\n    consumedLength: pos,\n    descriptor: descriptor,\n    releasePrevious: false,\n    releaseSelf: true,\n    repeat: 1\n  };\n}\nfunction readTag(text, pos, startBracket) {\n  var _text$slice$match, _text$slice$match$, _text$slice$match2;\n  var releasePreviousModifier = text[pos] === '/' ? '/' : '';\n  pos += releasePreviousModifier.length;\n  var descriptor = (_text$slice$match = text.slice(pos).match(/^\\w+/)) == null ? void 0 : _text$slice$match[0];\n  assertDescriptor(descriptor, text, pos);\n  pos += descriptor.length;\n  var repeatModifier = (_text$slice$match$ = (_text$slice$match2 = text.slice(pos).match(/^>\\d+/)) == null ? void 0 : _text$slice$match2[0]) != null ? _text$slice$match$ : '';\n  pos += repeatModifier.length;\n  var releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n  pos += releaseSelfModifier.length;\n  var expectedEndBracket = bracketDict[startBracket];\n  var endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n  if (!endBracket) {\n    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', \"\\\"\".concat(expectedEndBracket, \"\\\"\")].filter(Boolean).join(' or '), text[pos], text));\n  }\n  pos += endBracket.length;\n  return {\n    consumedLength: pos,\n    descriptor: descriptor,\n    releasePrevious: !!releasePreviousModifier,\n    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n    releaseSelf: hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier)\n  };\n}\nfunction assertDescriptor(descriptor, text, pos) {\n  if (!descriptor) {\n    throw new Error(getErrorMessage('key descriptor', text[pos], text));\n  }\n}\nfunction getEnumValue(f, key) {\n  return f[key];\n}\nfunction hasReleaseSelf(startBracket, descriptor, releaseSelfModifier, repeatModifier) {\n  if (releaseSelfModifier) {\n    return releaseSelfModifier === '/';\n  }\n  if (repeatModifier) {\n    return false;\n  }\n  if (startBracket === '{' && getEnumValue(legacyModifiers, descriptor.toLowerCase())) {\n    return false;\n  }\n  return true;\n}\nfunction mapLegacyKey(descriptor) {\n  var _getEnumValue;\n  return (_getEnumValue = getEnumValue(legacyKeyMap, descriptor)) != null ? _getEnumValue : descriptor;\n}\nfunction getErrorMessage(expected, found, text) {\n  return \"Expected \".concat(expected, \" but found \\\"\").concat(found != null ? found : '', \"\\\" in \\\"\").concat(text, \"\\\"\\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\\n    for more information about how userEvent parses your input.\");\n}","map":null,"metadata":{},"sourceType":"script"}