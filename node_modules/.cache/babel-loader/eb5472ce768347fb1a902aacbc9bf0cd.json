{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"D:\\\\React\\\\testapp1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"D:\\\\React\\\\testapp1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preKeyupBehavior = exports.preKeydownBehavior = exports.postKeyupBehavior = exports.keyupBehavior = exports.keypressBehavior = exports.keydownBehavior = void 0;\nvar _dom = require(\"@testing-library/dom\");\nvar _utils = require(\"../../utils\");\nvar _getEventProps = require(\"../getEventProps\");\nvar _shared = require(\"../shared\");\n\n/**\n * This file should contain behavior for functional keys as described here:\n * https://w3c.github.io/uievents-code/#key-alphanumeric-functional\n */\nvar modifierKeys = {\n  Alt: 'alt',\n  Control: 'ctrl',\n  Shift: 'shift',\n  Meta: 'meta'\n};\nvar preKeydownBehavior = [].concat(_toConsumableArray(Object.entries(modifierKeys).map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    key = _ref2[0],\n    modKey = _ref2[1];\n  return {\n    matches: function matches(keyDef) {\n      return keyDef.key === key;\n    },\n    handle: function handle(keyDef, element, options, state) {\n      state.modifiers[modKey] = true;\n    }\n  };\n})), [\n// AltGraph produces an extra keydown for Control\n// The modifier does not change\n{\n  matches: function matches(keyDef) {\n    return keyDef.key === 'AltGraph';\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _options$keyboardMap$;\n    var ctrlKeyDef = (_options$keyboardMap$ = options.keyboardMap.find(function (k) {\n      return k.key === 'Control';\n    })) != null ? _options$keyboardMap$ : /* istanbul ignore next */\n    {\n      key: 'Control',\n      code: 'Control'\n    };\n    _dom.fireEvent.keyDown(element, (0, _getEventProps.getKeyEventProps)(ctrlKeyDef, state));\n  }\n}]);\nexports.preKeydownBehavior = preKeydownBehavior;\nvar keydownBehavior = [{\n  matches: function matches(keyDef) {\n    return keyDef.key === 'CapsLock';\n  },\n  handle: function handle(keyDef, element, options, state) {\n    state.modifiers.caps = !state.modifiers.caps;\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    return keyDef.key === 'Backspace' && (0, _utils.isEditable)(element) && !(0, _utils.isCursorAtStart)(element);\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _ref3 = (0, _utils.calculateNewValue)('', element, state.carryValue, undefined, 'backward'),\n      newValue = _ref3.newValue,\n      newSelectionStart = _ref3.newSelectionStart;\n    (0, _shared.fireInputEvent)(element, {\n      newValue: newValue,\n      newSelectionStart: newSelectionStart,\n      eventOverrides: {\n        inputType: 'deleteContentBackward'\n      }\n    });\n    (0, _shared.carryValue)(element, state, newValue);\n  }\n}];\nexports.keydownBehavior = keydownBehavior;\nvar keypressBehavior = [{\n  matches: function matches(keyDef, element) {\n    return keyDef.key === 'Enter' && (0, _utils.isElementType)(element, 'input') && ['checkbox', 'radio'].includes(element.type);\n  },\n  handle: function handle(keyDef, element) {\n    var form = element.form;\n    if ((0, _utils.hasFormSubmit)(form)) {\n      _dom.fireEvent.submit(form);\n    }\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    return keyDef.key === 'Enter' && ((0, _utils.isClickableInput)(element) ||\n    // Links with href defined should handle Enter the same as a click\n    (0, _utils.isElementType)(element, 'a') && Boolean(element.href));\n  },\n  handle: function handle(keyDef, element, options, state) {\n    _dom.fireEvent.click(element, (0, _getEventProps.getMouseEventProps)(state));\n  }\n}, {\n  matches: function matches(keyDef, element) {\n    return keyDef.key === 'Enter' && (0, _utils.isElementType)(element, 'input');\n  },\n  handle: function handle(keyDef, element) {\n    var form = element.form;\n    if (form && (form.querySelectorAll('input').length === 1 || (0, _utils.hasFormSubmit)(form))) {\n      _dom.fireEvent.submit(form);\n    }\n  }\n}];\nexports.keypressBehavior = keypressBehavior;\nvar preKeyupBehavior = _toConsumableArray(Object.entries(modifierKeys).map(function (_ref4) {\n  var _ref5 = _slicedToArray(_ref4, 2),\n    key = _ref5[0],\n    modKey = _ref5[1];\n  return {\n    matches: function matches(keyDef) {\n      return keyDef.key === key;\n    },\n    handle: function handle(keyDef, element, options, state) {\n      state.modifiers[modKey] = false;\n    }\n  };\n}));\nexports.preKeyupBehavior = preKeyupBehavior;\nvar keyupBehavior = [{\n  matches: function matches(keyDef, element) {\n    return keyDef.key === ' ' && (0, _utils.isClickableInput)(element);\n  },\n  handle: function handle(keyDef, element, options, state) {\n    _dom.fireEvent.click(element, (0, _getEventProps.getMouseEventProps)(state));\n  }\n}];\nexports.keyupBehavior = keyupBehavior;\nvar postKeyupBehavior = [\n// AltGraph produces an extra keyup for Control\n// The modifier does not change\n{\n  matches: function matches(keyDef) {\n    return keyDef.key === 'AltGraph';\n  },\n  handle: function handle(keyDef, element, options, state) {\n    var _options$keyboardMap$2;\n    var ctrlKeyDef = (_options$keyboardMap$2 = options.keyboardMap.find(function (k) {\n      return k.key === 'Control';\n    })) != null ? _options$keyboardMap$2 : /* istanbul ignore next */\n    {\n      key: 'Control',\n      code: 'Control'\n    };\n    _dom.fireEvent.keyUp(element, (0, _getEventProps.getKeyEventProps)(ctrlKeyDef, state));\n  }\n}];\nexports.postKeyupBehavior = postKeyupBehavior;","map":null,"metadata":{},"sourceType":"script"}